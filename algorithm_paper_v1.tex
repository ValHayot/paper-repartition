\documentclass[sigconf, nonacm]{acmart}

\usepackage{amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage{xcolor,colortbl}
\usepackage{algorithmic, algorithm}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xspace}
\usepackage{hyperref} % makes cross-refs (biblio, figures, algos, ...) clickable

%% The following content must be adapted for the final version
% paper-specific
\newcommand\vldbdoi{XX.XX/XXX.XX}
\newcommand\vldbpages{XXX-XXX}
% issue-specific
\newcommand\vldbvolume{14}
\newcommand\vldbissue{1}
\newcommand\vldbyear{2020}
% should be fine as it is
\newcommand\vldbauthors{\authors}
\newcommand\vldbtitle{\shorttitle} 
% leave empty if no availability url should be set
\newcommand\vldbavailabilityurl{http://vldb.org/pvldb/format_vol14.html}
% whether page numbers should be shown or not, use 'plain' for review versions, 'empty' for camera ready
\newcommand\vldbpagestyle{plain} 

\newcommand{\logic}[1]{\color{red}\textbf{Logic/flow:}#1\color{black}}
\newcommand{\writing}[1]{\color{green}\textbf{Writing:}#1\color{black}}
\newcommand{\tristan}[1]{\color{orange}\textbf{From Tristan:}#1\color{black}}
\newcommand{\timothee}[1]{\color{blue}\textbf{From Timothée:}#1\color{black}}
\newcommand{\keep}[0]{\textsc{keep}\xspace}

\begin{document}

\title{A sequential algorithm to repartition large multi-dimensional arrays}

\author{Timoth\'ee Gu\'edon, Val\'erie Hayot-Sasson, Tristan Glatard}

\affiliation{Department of Computer Science and Software Engineering\\Concordia University, Montreal, Canada}

\begin{abstract}
\tristan{Tristan to reword the abstract}
Multidimensional array chunking is a routine for scientists nowadays.
That is why efficiently processing such arrays is of major importance in the big data era.
Splitting and merging arrays has been successfully done, we therefore attempted
to solve the next step: the re-partitioning problem.
This problem consists in efficiently re-writing a chunked array to change the
blocks shape.
In this study we define the repartitioning problem and propose two algorithms to
solve it: a baseline algorithm and the keep algorithm.
With the keep algorithm, we try to reduce the number of seeks produced by the
re-partitioning problem in the hope of reducing the processing time.
We benchmark the performances of both algorithms on two cubic arrays of shape
(3500,3500,3500) and (8000,8000,8000), with different resolutions and different
amounts of available main memory.
Our results show that the re-partitioning problem can be optimized.
The baseline algorithm can perform surprisingly well under certain conditions
by leveraging the page cache instead of reducing the number of seeks. The keep
algorithm however, can be significantly faster than baseline when the amount of
memory available is smaller than the array size.

\end{abstract}

\maketitle

%%% do not modify the following VLDB block %%
%%% VLDB block start %%%
\pagestyle{\vldbpagestyle}
\begingroup\small\noindent\raggedright\textbf{PVLDB Reference Format:}\\
\vldbauthors. \vldbtitle. PVLDB, \vldbvolume(\vldbissue): \vldbpages, \vldbyear.\\
\href{https://doi.org/\vldbdoi}{doi:\vldbdoi}
\endgroup
\begingroup
\renewcommand\thefootnote{}\footnote{\noindent
This work is licensed under the Creative Commons BY-NC-ND 4.0 International License. Visit \url{https://creativecommons.org/licenses/by-nc-nd/4.0/} to view a copy of this license. For any use beyond those covered by this license, obtain permission by emailing \href{mailto:info@vldb.org}{info@vldb.org}. Copyright is held by the owner/author(s). Publication rights licensed to the VLDB Endowment. \\
\raggedright Proceedings of the VLDB Endowment, Vol. \vldbvolume, No. \vldbissue\ %
ISSN 2150-8097. \\
\href{https://doi.org/\vldbdoi}{doi:\vldbdoi} \\
}\addtocounter{footnote}{-1}\endgroup
%%% VLDB block end %%%

%%% do not modify the following VLDB block %%
%%% VLDB block start %%%
\ifdefempty{\vldbavailabilityurl}{}{
\vspace{.3cm}
\begingroup\small\noindent\raggedright\textbf{PVLDB Artifact Availability:}\\
The source code, data, and/or other artifacts have been made available at \url{\vldbavailabilityurl}.
\endgroup
}
%%% VLDB block end %%%


%----------------------------------------
\section{Introduction}
%----------------------------------------


% Multidimensional arrays are important
Multidimensional arrays are
used in many scientific disciplines as the main data structure~\cite{numpynature}. In neuroimaging, our main application area, arrays
commonly store 2D, 3D or 3D+t brain images acquired from histology, magnetic
resonance imaging (MRI), or other modalities. Due to the improvement of
acquisition methods, it is now common for such images to exceed the amount
of working memory available on typical computers, requiring their
partitioning in blocks stored in independent files or in multiple HDF5
sections. BigBrain~\cite{Amunts1472}, for instance, is a human brain model
providing microscopic data at the resolution of 20 micrometers that comes
in the form of many 3D blocks. Partitioning large arrays enables efficient
queries, flexibility in adding new data~\cite{optimal_chuking}, granular data
transfers, and parallel processing with frameworks such as
Dask~\cite{matthew_rocklin-proc-scipy-2015}. Applications may adopt
different block geometries depending on their processing requirements, such
as 2D slices or 3D blocks for images.

% Seeks create performance issues
Manipulating large multidimensional arrays, however, comes with performance
challenges related to the ordering and organization of array elements on
storage devices. For instance, reading elements scattered in different
disk locations can generate millions to billions of \emph{seeks}, the
processes by which storage drives move to a different location, resulting
in important penalties on both SSD and HDD drives. The ultimate goal of our
research is to minimize the number of seeks required when manipulating
large multi-dimensional arrays.

% Existing work
Currently, the main approach to this problem is to adapt the ordering of array
elements on storage devices to the type of queries done by applications.
For instance, the ndstore platform~\cite{ndstore} stores voxels of 3D images
in an order defined from Morton space-filling curves~\cite{morton}, so that nearby
voxels in the 3D space are stored at nearby disk addresses with high
probability, limiting the number of seeks required to read 3D blocks. Other works determine from past queries a
block shape that minimizes the expected number of seeks required
by queries~\cite{optimal_chuking}\tristan{Timothée, pls check that}.
While such approaches are efficient, they also require that data
be converted to a storage format specific to the application, which is
impractical and hampers data sharing. Instead, we are looking for
algorithmic approaches where applications control their I/Os to reduce seeking.

% Goal
This paper presents the "\keep heuristic", an algorithm to reduce the
number of seeks created when repartitioning large 3D images in blocks of
arbitrary shape. Repartitioning may be triggered by applications, when they
require blocks of specific shapes, or for performance reasons, to improve
memory usage and I/O efficiency. For instance, the Python HDF5 library
\texttt{h5py} recommends a chunk size ``between 10 KiB and 1
MiB"~\cite{collette_2014}, while the Dask parallel processing framework
~\cite{matthew_rocklin-proc-scipy-2015} suggests a chunk size greater than
100 MB~\cite{rocklin_bourbeau_2019}.

The \keep heuristic leverages a memory cache to read and write data as
contiguously as possible, similarly to the "clustered" and "multiple"
algorithms described in~\cite{seqalgorithms}. The storage order of array
elements on disk is assumed be known to the application, but unconstrained.
Implementations based on our algorithm could therefore use arbitrary file
formats. We focus on sequential algorithms, assuming that arrays are stored
on a single device and accessed by single-threaded I/Os. Extensions to parallel
environments are part of our future work. Although in practice seek times
depend on various factors, such as the distance between the initial and
target drive positions, we focus on minimizing seek \emph{numbers}, for
simplicity. Likewise, the effects of I/O optimizations such as page caching
or readahead will be discussed experimentally but not modeled.

In summary, the paper makes the following contributions:
\begin{itemize}
  \item We define the repartitioning problem for data arrays;
  \item We propose the \keep heuristic to the re-partitioning problem;
  \item We provide an open implementation on Github;
  \item We evaluate the heuristic on the BigBrain dataset.
\end{itemize}
The remainder defines the re-partitioning problem, presents the \keep heurstic and implementation, 
and reports experimental evaluation results.

% % need for tools to repartition
% Using chunked multidimensional arrays requires tools to efficiently split,
% merge, and ``resplit" or ``repartition" data files. Previous work in~\cite{seqalgorithms}
% showed that naive algorithms to split an array into several chunks or merge
% array chunks into one output file do not perform well due to millions of seeks
% occurring on disk. The present study is focused on sequential algorithms for
% repartitioning multidimensional arrays, letting the parallel and distributed
% cases as future work, although they are relevant, too. To the best of our
% knowledge, the repartition problem has not been extensively studied.



\section{Problem definition and baseline}
\begin{figure*}[h]
  \centering
  \includegraphics[scale=0.35]{./figures/new/figure_1.png}
  \caption{Illustration of the \texttt{C-order} in files. The left subfigure
  shows how the data is written on disk, with each cube representing a voxel.
  The green block is the first block in the C-order while the red one represents the last block.
  The right subfigure shows how reading or writing only one part of a cuboid written
  in the \texttt{C-order} can produce seeks. Each red voxel is a voxel producing a seek.}
  \label{fig:seeks_and_rowmajor}
\end{figure*}

For the sake of clarity and without loss of generality, we assume that
 files are written in row-major order (Fig~\ref{fig:seeks_and_rowmajor},
 a.k.a ``C" order), where the fastest moving dimension in the file is the
 last dimension of the array, and the slowest moving dimension in the file
 is the first dimension of the array. This convention is for instance the
 one used in the HDF5 format ~\cite{hdf5}. 

Accessing data from an array stored on disk generates seeks in two
situations: (1) when an array block is opened for reading or writing, and (2)
when the reading or writing process moves within the block. 
\tristan{update when figure-right is updated} For a 3D cuboid of shape $C = (C_i, C_j, C_k)$ stored
in row-major order, each column of data in the k dimension is contiguously
stored. There are therefore $C_j \times C_i$ data columns that all require a
seek (see Figure~\ref{fig:seeks_and_rowmajor} (b)).

\subsection{The re-partitioning problem}
We focus on 3D arrays for simplicity. Consider a 3D array of shape $A =
(A_i, A_j, A_k)$, partitioned as evenly-shaped input blocks of shape $I = (I_i,
I_j, I_k)$ stored on disk. Our goal is to re-partition the input blocks into
evenly-shaped output blocks of shape $O = (O_i, O_j, O_k)$, where $O \neq I$.

We formalize the re-partitioning problem as follows.
A re-partioning algorithm (Algorithm~\ref{algo:generalrepartition}) takes a
list of input blocks \texttt{inBlocks} of shape $I$, a list of output
blocks \texttt{outBlocks} of shape $O$, and the amount of memory \texttt{m}
available for the algorithm. Subject to $m$, the algorithm (line 7) determines (1)
\texttt{readBlocks}, a list of evenly-shaped blocks of shape $R$ to be read from the
input blocks, and (2) \texttt{writeBlocks}, a list of blocks,
usually not evenly-shaped, where each block contains a contiuous piece of
data that will be written in an output block with a single seek.
If read blocks and input blocks have a different shape, then reading read blocks requires
more than one seek. Similarly, if write blocks and output blocks have a different shape,
then writing write blocks requires more than one seek. Input, output, read
and write blocks all form a partition of the 3D array of shape $A$. The
main loop of the algorithm (line 9) loads one read block at a time (line
10), inserts it into a cache (line 11), and writes write blocks from the
cache when they are complete (lines 12 to 17).

It should be noted that blocks are passed to the algorithm by reference,
not by data. Only variables \texttt{data} (line 10, 14) and \texttt{cache}
(line 11) hold actual data, contributing to the consumed memory. 

Since read and write blocks both represent a partition of $A$, all the
elements in $I$ are read exactly once, and written exactly once too. Other
problem formalizations may allow for input elements to be read and
discarded, to reduce seeks. Exploring such a trade-off
between seeks and redundant reads could be an interesting extension to this problem.

Our goal is to minimize the number of seeks done by the algorithm, which
occur during reads (line 13) and writes (line 16 \tristan{check all line numbers}). We define a cost
function $\mathrm{seeks}$ that returns the number of seeks incurred by the
repartitioning algorithm. 
The re-partitioning problem is therefore to find
the best read and write block lists in order to minimize $\mathrm{seeks}$
subject to the memory constraint $m$. 

% Problem: re-partitioning of multi-dimensional arrays
% Find: readBlocks and writeBlocks 
% Subject to: m
% Such that: seeks is minimal
% \tristan{formalize problem definition}.

Solutions of this problem materialize as implementations of function
\texttt{getReadWriteBlocks} in Algorithm~\ref{algo:generalrepartition}. A
lower bound on the number of seeks for the repartitioning problem is $n_i +
n_o$, with $n_i$ the number of input files and $n_o$ the number of output
files. Indeed, input and output files all have to be accessed at least
once, which requires a seek.

For simplicity, we require that all blocks in \texttt{readBlocks} have
the same shape $R$ \tristan{justify that better}. We also equate the size of an
array in memory as its number of elements.
\tristan{we assume that input and output blocks fit in memory}

\begin{algorithm}
  \caption{General re-partitioning algorithm}
  \label{algo:generalrepartition}
  \begin{algorithmic}[1]
    \STATE \textbf{Inputs}
    \STATE inBlocks: input blocks of shape $I$, stored on disk
    \STATE outBlocks: output blocks of shape $O$, to be written
    \STATE $m$: memory available
    \STATE
    \STATE \textbf{Outputs}
    \STATE none (outBlocks are written)
    \STATE
    \STATE \textbf{Algorithm}
    \STATE readBlocks, writeBlocks $\leftarrow$ getReadWriteBlocks($I$, $O$, $m$)
    \STATE initialize(cache)
    \FOR{readBlock in readBlocks}
      \STATE data $\leftarrow$ read(readBlock, inBlocks)
      \STATE cache.insert(data)
      \FOR{writeBlock in writeBlocks}
        \IF{cache.isComplete(writeBlock)}
          \STATE data $\leftarrow$ cache.pop(writeBlock)
          \STATE write(data, outBlocks)
        \ENDIF
      \ENDFOR
    \ENDFOR

  \end{algorithmic}
\end{algorithm}

\tristan{Maybe add a figure to show input blocks, read blocks, write blocks, output blocks}

\subsection{The split and merge problems}

Special cases of the re-partitioning problem occur when $I=A$ (``split'' problem)
or when $O=A$ (``merge'' problem). Two strategies were introduced
in~\cite{seqalgorithms} to address these problems: the ``multiple" and the
``clustered" strategies. In these strategies, every read block is directly written to the
destination output files, that is, \texttt{readBlocks} and \texttt{writeBlocks} are identical, .
The only difference between the multiple and the clustered strategies lies in
the selection of $R$.

In the split problem studied in~\cite{seqalgorithms} ($I=A$), the naive
strategy defines the read blocks as having the same shape as the output blocks
($R$=$O$). The read blocks are iteratively loaded from $A$ and entirely written
to the appropriate output block (represented by a write block of shape $O$, too).
The "clustered" strategy, however, loads as
many contiguous read blocks of shape $O$ as possible to fit in $m$.
$R$ is therefore a multiple of $O$.
Depending on the amount of main memory available, read blocks may be loaded
individually, by entire block columns, or by entire block slabs.
Although this strategy allows to write each output block in one seek, the clustered strategy is limited by the fact
that it does not optimize the reading step.
In the general re-partitioning problem, one can expect the clustered strategy to
perform poorly as
(1) it reads an output block regardless of its spread among input blocks
and (2) even if it is stored in one input block the algorithm will do a lot of seeks in
case of a shape mismatch \tristan{I dont get (2), to be clarified}.

The "multiple" strategy used for the split problem in~\cite{seqalgorithms}
aims at not doing any seek while reading \textit{and} writing;
Both the input and the output blocks are read/written contiguously. In
terms of Algorithm~\ref{algo:generalrepartition}, it means defining read blocks as
contiguous parts of the input array and write blocks as contiguous parts of
the output arrays. It is equivalent to extending the buffer \tristan{read blocks or write blocks?} in the inverse of
the storage order: $k \rightarrow j \rightarrow i$ in the case
of the \texttt{C-order}. Although the multiple strategy does not seek while reading or writing, it 
requires many switches between output blocks, which also requires seeking. 

To the best of our knowledge, no algorithm has been proposed for the
repartitioning task \tristan{maybe comment more}.

\subsection{Baseline}

Our baseline algorithm for the repartitioning problem loads one input block
at a time ($R$=$I$), and directly writes it to the appropriate output
blocks ($W$=$R$). It assumes that input blocks fit in memory. The number of
seeks $s$ created by this baseline for writes 
depends on how write blocks overlap with
output blocks in each dimension (Fig\ref{fig:cuts} \tristan{Timothee, faire une figure 
qui represente les deux plans (X0, X1) et (X1, X2) en utilisant les notations ci-dessous}). We define
$\mathcal{W}_d$ and $\mathcal{O}_d$ the sets of write and output block end
coordinates in dimension $d$:
\[
  \forall d \in \llbracket 1, 3 \rrbracket,
\]
\begin{equation}
  \mathcal{W}_d = \Big\{ iW_d, i \in \llbracket 1, A_d/W_d \rrbracket \Big\} \quad \mathrm{and} \quad
  \mathcal{O}_d = \Big\{ iO_d, i \in \llbracket 1, A_d/O_d \rrbracket \Big\} ~\label{eq:baseline-blocks}
\end{equation}
We then define the \emph{cuts} of the $i^{th}$ output block along dimension
$d$ as follows:
\[
  \forall i \in \llbracket 1, A_d/O_d \rrbracket,
\]
\[
  C_{i, d} = C_{i, d}\left(  \mathcal{W}_d, \mathcal{O}_d \right) = \Big\{ w \in \mathcal{W}_d, (i-1)O_d < w < iO_d \Big\}
\]
The number of output block pieces along dimension $d$ is then:
\[
  c_d = c_d\left(  \mathcal{W}_d, \mathcal{O}_d \right) =
               \sum_{i=1}^{A_d/O_d} \vert C_{i, d}\left(  \mathcal{W}_d, \mathcal{O}_d \right) \vert + 1 - \delta_{\vert C_{i, d}\left(  \mathcal{W}_d, \mathcal{O}_d \right) \vert, 0}
\]
where $\vert$ . $\vert$ is the cardinality operator and $\delta$ is the Kronecker delta. 
The number of matching endings is:
\[
  m_d = m_d\left(  \mathcal{W}_d, \mathcal{O}_d \right) = \vert \mathcal{W}_d \cup  \mathcal{O}_d \vert  - c_d
  \]
Finally, the number of seeks created by the baseline algorithm is:
\begin{equation}
  s_b = A_0 A_1 c_2 + 
      A_0 c_1 m_2 +
      c_0 m_1 m_2
       + n_i + n_o \label{eq:seeks-baseline}
\end{equation}


As can be seen from Equation~\ref{eq:seeks-baseline}, cuts along dimension 2 generate $\mathcal{O}(A_0 A_1)$
seeks, cuts along dimension 1 generate $\mathcal{O}(A_0)$ seeks and cuts in
dimension 0 generate $\mathcal{O}(1)$ seeks. The \keep heuristic described
in the next section aims at avoiding seeks primarily in dimension 2, and if
possible in dimension 1 and 0. An experimental verification of the model will be provided in 
Section ~\ref{sec:experiments}.

\begin{table}
  \begin{tabular}{ll}
    \multicolumn{2}{c}{\cellcolor{black!25}Bold capitals are used for array partitions}\\
    \textbf{A} & 3D array to repartition \\
    \textbf{I} & Set of input blocks \\
    \textbf{O} & Set of output blocks \\
    &\\
    \multicolumn{2}{c}{\cellcolor{black!25}Plain capitals are used for block shapes}\\
    A = ($A_0$, $A_1$, $A_2$) & shape of \textbf{A}\\
    I = ($I_0$, $I_1$, $I_2$)& shape of input blocks\\
    O = ($O_0$, $O_1$, $O_2$) & shape of output blocks\\
    R = ($R_0$, $R_1$, $R_2$) & shape of read blocks\\
    W = ($W_0$, $W_1$, $W_2$) & shape of write blocks\\
    &\\
    \multicolumn{2}{c}{\cellcolor{black!25}Round capitals are used for block end coordinates}\\

    $\mathcal{I}$ = ($\mathcal{I}_0$, $\mathcal{I}_1$, $\mathcal{I}_2$), \enskip $\mathcal{I}_d \subset \mathbb{N} $ & coordinates of input block endings \\
    $\mathcal{O}$ = ($\mathcal{O}_0$, $\mathcal{O}_1$, $\mathcal{O}_2$), \enskip $\mathcal{O}_d \subset \mathbb{N} $ & coordinates of output block endings\\
    $\mathcal{R}$ = ($\mathcal{R}_0$, $\mathcal{R}_1$, $\mathcal{R}_2$), \enskip $\mathcal{R}_d \subset \mathbb{N} $ & coordinates of read block endings\\
    $\mathcal{W}$ = ($\mathcal{W}_0$, $\mathcal{W}_1$, $\mathcal{W}_2$), \enskip $\mathcal{W}_d \subset \mathbb{N} $ & coordinates of write block endings\\
    &
  \end{tabular}
  \caption{Summary of notations}
\end{table}


% We implemented Equation~\ref{eq:1} and ran it on a cubic array to confirm these
% theories. One shape mismatch is added at a time in order to see the impact on
% the number of seeks. The setting and results of this simulation are summarized
% in table~\ref{tab:simseekmodel}.

% \begin{table}[ht]
%   \centering
%   \caption{Results of the simulation using the baseline algorithm's seek model}

%    \begin{tabular}[t]{| c | c | c | c | c |}
%    \hline
%    Mismatch & R & B=I & O & nb seeks \\
%      \hline\hline
%      k & (3500,3500,3500) & (500,500,875) & (500,500,500) & 73,500,000 \\
%      \hline
%      j & (3500,3500,3500) & (500,875,500) & (500,500,500) & 147,000 \\
%      \hline
%      i & (3500,3500,3500) & (875,500,500) & (500,500,500) & 294 \\
%      \hline
%      i,j & (3500,3500,3500) & (875,875,500) & (500,500,500) & 147,168 \\
%      \hline
%      i,j,k & (3500,3500,3500) & (875,875,875) & (500,500,500) & 73,584,096 \\
%      \hline
%    \end{tabular}

%    \label{tab:simseekmodel}

% \end{table}

%----------------------------------------
\section{The \keep heuristic}
%----------------------------------------

As mentioned previously, the baseline, split, and merge strategies empty
the cache at each iteration, which generates many seeks in case of a shape
mismatch between the input and output blocks. Instead, the proposed
\keep heuristic tries to maintain data in the cache when it cannot be written
contiguously to the output blocks. 

% (Figure~\ref{fig:keepvsbaseline})
% \begin{figure}[h]
% \centering
% \includegraphics[scale=0.4]{./figures/new/figure_2.png}
% \caption{This figure illustrates the difference between the keep and the baseline algorithm.
% The first read buffer (on top, grey) is divided in parts by its intersections with output blocks.
% While the baseline algorithm writes every part of the read buffer into the appropriate output
% blocks (blue cubes are written directly), the keep algorithm writes only the output block
% that is complete, and leave the rest in cache until the other parts of the output blocks have been
% loaded (red cubes stay in cache). In this figure, $B=\Lambda$.
% }
% \label{fig:keepvsbaseline}
% \end{figure}

\subsection{Overview}

\begin{algorithm}
  \caption{\keep heuristic (implements \texttt{getReadWriteBlocks}) \tristan{verify all line numbers in the text, they have changed}}
  \label{algo:keep}
  \begin{algorithmic}[1]
    \STATE \textbf{Inputs}
    \STATE inBlocks: input blocks of shape $I$, stored on disk
    \STATE outBlocks: output blocks of shape $O$, to be written
    \STATE $m$: memory available
    \STATE
    \STATE \textbf{Outputs}
    \STATE readBlocks: a list of read blocks
    \STATE writeBlocks: a list of write blocks
    \STATE
    \STATE \textbf{Algorithm}
    \STATE readShapes = candidateReadShapes($I$, $O$)
    \STATE minSeeks = None
    \FOR{$R$ in readShapes}
      \STATE writeBlocks = split(readBlocks, outBlocks)
      \STATE m' = memoryConsumed($R$, writeBlocks, $O$)
      \IF{m' > m}
      \STATE \textbf{continue} \COMMENT{Read shape cannot respect memory constraint}
      \ENDIF
      \IF{$R$ == $\Lambda$}
      \STATE \textbf{break} \COMMENT{$\Lambda$ respects memory constraint}
      \ENDIF
      \STATE writeBlocks = mergeWriteBlocks(writeBlocks, $O$, $m$)
      \STATE s' = generatedSeeks($I$, $R$, writeBlocks, $O$)
      \IF{minSeeks == None or s' < minSeeks}
      \STATE minSeeks, bestReadShape = s', $R$
      \ENDIF
    \ENDFOR
    \STATE readBlocks = blocks($R$)
    \RETURN readBlocks, writeBlocks
  \end{algorithmic}
\end{algorithm}
The \keep heuristic (Alg.~\ref{algo:keep}) is a brute-force search
of the best read shape among a list of candidates (line 11).  
For each candidate read shape, it initializes a list of write blocks (line
14), determines the memory consumed by this solution (line 15), and provided that the
memory constraint is respected, merges write blocks as much as allowed by the memory 
constraint (line 19), computes 
the number of seeks created by the solution (line
20), and selects the read shape that minimizes the number of seeks (line
21-23). Finally, a list of read blocks is generated from the  selected read shape (line
25), and the algorithm returns.

The \keep heuristic uses the following functions, described in the
remainder of this section: \texttt{candidateReadShapes} (line 11),
\texttt{split} (line 14), \texttt{memoryConsumed} (line 15),
\texttt{generatedSeeks} (line 20), \texttt{mergeWriteBlocks} (line 19).

\subsection{Candidate read shapes}

% Read shape candidates are generated as to avoid cuts along dimension 2
% during reads and writes. Ideally, the read shape would cover an exact
% number of input blocks, to avoid seeks during reads, and would include at
% least one output block, to avoid seeks during writes. In practice, this
% might not be possible due to memory limitations, since at each iteration
% the parts of the read block that are not written must remain in cache.

To generate candidate read shapes (\texttt{candidateReadShapes}, line 11), we first define a shape $\Lambda$ such
that in each dimension $d$, $\Lambda_d$ is the smallest multiple of $I_d$
that is greater or equal to $O_d$:

\[
\forall d \in \{1, 2, 3\},
\]
\[
  \enskip \exists \hat k \in \mathbb{N}, \enskip \Lambda_d = \hat kI_d \enskip \mathrm{and} \enskip \hat k I_d \geq O_d \enskip \mathrm{and} \enskip \forall k < \hat k, \enskip kI_d < O_d
\]

Using $\Lambda$ as read shape minimizes the seeks in the input blocks, as
in this situation each iteration reads input blocks completely, requiring a
single seek per input block. If there is enough memory to use write blocks
of shape $O$, then this solution also minimizes the seeks in the output
blocks, as output blocks can be written in a single seek too.

Function \texttt{getCandidateReadShape} returns the following shapes:
\[
  \Big\{ (C_0, C_1, \Lambda_2) \in \mathbb{N}^3 \enskip / \enskip
          \forall i \in \{1, 2\}, \enskip \exists k_i \in \mathbb{N}, \enskip
           A_i = k_iC_i \enskip \mathrm{and} \enskip C_i \leq \Lambda_i \Big\}
\]
The third coordinate of all read shapes is set to $\Lambda_2$, to guarantee
that no cuts along dimension 2 will be made during reads. This assumes that
$m > \Lambda_2$, i.e., a block of shape (1, 1, $\Lambda_k$) fits in
memory. The other two coordinates are set to divisors of $A_0$ and $A_1$ which are
less than or equal to $\Lambda_0$ and $\Lambda_1$. 

The candidate shapes are sorted such that $\Lambda$ is first.
While $\Lambda$ is the optimal read shape, leading to a single seek per
input or output block, there is no obvious relation between the other
candidate shapes and the number of seeks that they generate, since this
number depends on how input, read, write, and output block shapes are
arranged. For this reason, the \keep heuristic returns if $\Lambda$ respects 
the memory constraint (line 20), but it otherwise evaluates all the other read shapes.

\subsection{Splitting read blocks by output blocks}

At each iteration, the read blocks are split by output blocks to initialize
the write blocks (\texttt{split}, line 14 in Alg~\ref{algo:keep}). It means that when a
read block covers more than a single output block, a write block is defined
for each output block, as the intersection between the output block and the
read block. 

\subsection{Consumed memory}
\tristan{Tristan to reformulate this section, needs discussion with Timothée}
Algorithm~\ref{algo:max_mem_keep_algorithm} describes how we compute the
maximum amount of memory consumed by the keep algorithm given a read buffer shape $B$.
Given the buffer order $k\rightarrow j\leftarrow i$, the algorithm computing
the maximum memory consumption of the keep algorithm comes from the following
observation:
At a maximum, the keep algorithm keeps 1 remainder of type $F_1$,
$n_k$ times $F_2$ and $F_3$ in the $j$ dimension and $n_k*n_j$ times $F_4$, $F_5$,
$F_6$ and $F_7$, with $n_x$ the number of buffers in dimension $x$.
For example if a first $F_1$ remainder is loaded by the first read buffer it
will be written down by the second read buffer, which will also load another $F_1$
volume.
The same observation applies to remainders in the $j$ and $i$ dimensions.
Therefore, at each buffer loading, the amount of memory in RAM is the sum of the
new buffer that has just been loaded and the amount of memory in cache from
previous buffers.
At any step of the algorithm, there is one buffer being loaded, the amount of
memory $mem$ is therefore initialized to the size of a read buffer line 7 of
Algorithm~\ref{algo:max_mem_keep_algorithm}.
At the beginning of the algorithm, the remainder lists are empty which is why
for the first buffer the memory used is just the read buffer size.
We therefore initialized $maxMem$ to $mem$ line 8.
In order to track the amount of memory in cache, we initialize three empty lists
(line 9): $list_k$, $list_j$ and $list_i$ of respective size of 1, $n_k$ and $n_k*n_j$.
We then simulate the keep algorithm process, computing the amount of RAM consumed at
each step.
For each read buffer, some remainder volumes are replaced: some are written
while others (of the same type) are being loaded.
We therefore remove the size of the remainders being written from $mem$ (line 20)
and we add the size of the new remainders instead (line 25).
Note that when processing buffer n°$i$ the final amount of memory $mem$ tested
line 27 is the amount of memory used after loading buffer $i+1$.
\begin{algorithm}
  \caption{Estimation of the maximum memory consumption of the keep algorithm}
  \label{algo:max_mem_keep_algorithm}
  \begin{algorithmic}[1]
    \STATE \textbf{Inputs}
    \STATE readBuffers: list of the read buffers created by the keep algorithm.
    \STATE $B$: read buffer shape
    \STATE $R$: shape of reconstructed image
    \STATE
    \STATE \textbf{Algorithm}
    \STATE $mem = B_k*B_j*B_i$
    \STATE $memMax = mem$
    \STATE $list_k, list_j, list_i = list(), list(), list()$
    \STATE
    \FOR{readBuffer in readBuffers}
      \STATE $F_1$, $F_2$, ..., $F_7= getRemainders(readBuffer)$
      \STATE $remainders_k = size(F_1)$
      \STATE $remainders_j = size(F_2+F_3)$
      \STATE $remainders_i = size(F_4+F_5+F_6+F7)$
      \STATE $index3D = getPosition(readBuffer,R)$
      \STATE
      \STATE $index_j = index3D_k$
      \STATE $index_i = index3D_j*length(list_j) + index3D_k$
      \STATE $mem \mathrel{-}= (list_k[0] + list_j[index_j] + list_i[index_i])$
      \STATE
      \STATE $list_k[0] = remainders_k$
      \STATE $list_j[index_j] = remainders_j$
      \STATE $list_i[index_i] = remainders_i$
      \STATE $mem \mathrel{+}= (list_k[0] + list_j[index_j] + list_i[index_i])$
      \STATE
      \IF{$mem>memMax$}
        \STATE $memMax\leftarrow mem$
      \ENDIF
    \ENDFOR
    \RETURN $memMax$
  \end{algorithmic}
\end{algorithm}

In order to perform the bruteforce search of the best read buffer shape $B$,
we need a way to compute the maximum memory consumption of the algorithm using
this shape.
Having partitioned the buffers into remainder volumes, the maximum memory
consumption can be computed by simulating the re-partition algorithm and
computing, at each step, the cache size.

Let us define $\Sigma$, the amount of data in RAM at a given time during the
execution of the re-partition algorithm.

In order to compute $\Sigma$, the volumes' sizes need to be computed using the
following nomenclature (Figure~\ref{fig:nomenclature_overlaps}):
Given a buffer shape $B$ and the output file shape $O$, we define $C_d(x)$ as
the overlap length between the buffer and an overlaping output file in direction
$d$ for the $x^{th}$ buffer. Let us define $\Omega$ and $\Theta$, that are used
to define upper bounds in the volumes sizes formulas. $\Omega_d(x)$ is the
equivalent of $C_d(x)$ if the buffer was of shape $\Lambda$, and $\Theta_k(x)$
is the difference between $B_d$ and $\Omega_b$, with $B=\Lambda$.
These metrics are computed as follows:
$$C_d(x) = (x+1)B_d mod(O_d)$$
$$\Omega_d(x) = (x+1)\Lambda_d mod(O_d)$$
$$\Theta_d(x) = \Lambda_d - \Omega_d(x)$$

To compute the maximum RAM consumption of the keep algorithm, given a
buffer shape, we first need to define what a remainder volume is.

A read buffer of shape $\Lambda$ can be divided in
8 parts or ``volumes" (Figure~\ref{fig:nomenclature_overlaps}).
7 out of these 8 volumes are called \texttt{remainder volumes} because
they are created by the shape mismatch between the input files and the output files on
the buffer borders.
The 7 remainder volumes enclose an 8th part that is composed of
input files that are either complete or which complementary part have already
been loaded by a previous buffer. This means that any complementary part is either
in memory (it has been kept in cache according to the keep strategy) or it has
been written down previously.
In other words the remainder volumes contain non contiguous parts of output blocks
as opposed to the non-remainder volume which contains a contiguous part of
an output block.

For read each buffer, each of volume
is indexed following the buffer ordering from $F_0$ to $F_7$, with $F_0$ being the
non-remainder volume. If the buffer is smallest than the input aggregate
($B_x<\Lambda_x$) or if there is no shape mismatch in a given dimension,
it may be that a volume size is set to 0.

\begin{figure*}[h]
\centering
\includegraphics[scale=0.4]{./figures/new/figure_3.png}
\caption{Illustration of an input aggregate (left) and its division into indexed remainder volumes (right).
Each remainder volume is a part of an output block.}
\label{fig:nomenclature_overlaps}
\end{figure*}


\subsection{Merging of write blocks}
\tristan{needs discussion with Timothée}
So far the process to define the read buffers has been described.
getWriteBuffers defines the blocks of data that will be written at once in each
output file.
In the baseline algorithm, the write buffers are defined as the
intersection between the read buffers and the output blocks.
In the context of the keep strategy, some of the remainder volumes are kept in cache
to be written together with other remainder volume(s) contiguously in the output
blocks.
This is equivalent to initializing the write buffers with the same definition as
in the baseline algorithm, and then fusing some of them to be written at once.
The way in which the remainder volumes are fused is summarized in
Table~\ref{tab:fusion}.

\begin{table}[ht]
  \centering
  \caption{Direction(s) in which to fuse the remainder volumes according to the keep strategy, in order to define the write buffers.}

   \begin{tabular}[t]{ | c | c | }
   \hline
   remainder volume's index & direction(s) for the fusion \\
     \hline\hline
     1 & k \\
     \hline
     2 & j \\
     \hline
     3 & j,k \\
     \hline
     4 & i \\
     \hline
     5 & i,k \\
     \hline
     6 & i,j \\
     \hline
     7 & i,j,k \\
     \hline
   \end{tabular}

   \label{tab:fusion}

\end{table}

\subsection{Number of generated seeks}

Similar to the
baseline, seeks generated by the \keep heuristic happen during reads (line
13 in Alg.~\ref{algo:generalrepartition}) and during writes (line 18). The
seeks generated during writes are directly obtained from
Equation~\ref{eq:seeks-baseline}, defining $\mathcal{W}_d$ as the end coordinates of
\texttt{writeBlocks}. To count the seeks generated
during reads, we note that the read process is dual to the write process:
writing in-memory blocks with end coordinates $\mathcal{M}$ to disk blocks
with end coordinates $\mathcal{D}$ generates the same number of seeks as
reading disk blocks with end coordinates $\mathcal{D}$ to in-memory blocks
with end coordinates $\mathcal{M}$. This number of seeks is returned by the following function:

\begin{eqnarray*}
  \textsc{seek} \left(  \mathcal{M}, \mathcal{D} \right) &=&  A_0 A_1 c_2\left(\mathcal{M}_d, \mathcal{D}_d\right) + \\
                                                         &&  A_0 c_1\left(\mathcal{M}_d, \mathcal{D}_d\right) m_2\left(\mathcal{M}_d, \mathcal{D}_d\right) +\\
                                                         && c_0\left(\mathcal{M}_d, \mathcal{D}_d\right) m_1\left(\mathcal{M}_d, \mathcal{D}_d\right) m_2\left(\mathcal{M}_d, \mathcal{D}_d \right)\\
                                                         && + \vert \mathcal{D} \vert
\end{eqnarray*}
Equation~\ref{eq:seeks-baseline} becomes:
\[
  s_b = \textsc{seek} \left( \mathcal{W}, \mathcal{O} \right) + n_i
\]
where $\mathcal{W}$ and $\mathcal{O}$ are defined as in
Equation~\ref{eq:baseline-blocks}. It should be noted that function
\textsc{seek} does not assume that $\mathcal{M}$ or $\mathcal{O}$ relate to
blocks of uniform shape. Therefore, it can be applied to the \keep
heuristics where write blocks are not necessarily of uniform shape.
The number of seeks generated by the \keep algorithm is given by:
\begin{equation}
  s_k = \textsc{seek} \left(  \mathcal{R}, \mathcal{I} \right) + \textsc{seek} \left( \mathcal{W}, \mathcal{O} \right) \label{eq:seeks-keep}
\end{equation}
where the first term represents the number of seeks required to read input
 blocks of end coordinates $\mathcal{I}$ into read blocks of end
 coordinates $\mathcal{R}$, and the second term represents the number of
 seeks required to write write blocks of end coordinates $\mathcal{W}$ into
 output blocks of end coordinates $\mathcal{O}$. Function
 \texttt{generatedSeeks}, called in Algorithm~\ref{algo:keep} (line 20) is
 a direct implementation of Equation~\ref{eq:seeks-keep}.

 \tristan{Validate seek model, see implementation of function seek in seek\_tristan.py}



%----------------------------------------
\section{Implementation}
%----------------------------------------

\subsection{Project repository and programming language}
The baseline algorithm and the ``keep" algorithm have been implemented in plain
Python 3.7.
The Python environment used was a conda environment, all packages used together
with their version are available in a \texttt{requirements.txt} file.
The instructions about how to install the dependencies in a virtual or conda
environement are provided in the \texttt{README} file of the
\href{https://github.com/GTimothee/repartition_experiments}{project's repository}.
The code for all experiments can be found in the same repository as well.

Finally, although we used the HDF5 file format for our experiments, the code
uses an instance of a so-called ``file manager" so that using our code with
another file format is as simple as implementing a new file manager object.

\subsection{Optimizing the main processing loop}
Instead of looping over all write buffers line 15 of
Algorithm~\ref{algo:generalrepartition} we implemented an optimization in
the keep algorithm:
We first compute a Python dictionary associating each buffer to the output files
it crosses or includes.
It allows to search only for the write buffers that write into the output files
crossed by the read buffer loaded. When a write buffer has been written, it
is also deleted from the list of write buffers which reduces even more the
computation time.

\subsection{Optimizing the bruteforce search}
One can note that when the read buffer shape $B$ is smaller than $\Lambda$,
the overall number of buffers increases.
It is therefore quicker to compute the number of seeks and the maximum
quantity of memory to be used for the buffers close to $\Lambda$.
On the contrary, it can take several seconds to compute theses metrics for
small buffers, knowing that among the possible buffer shapes, it is not rare to
see buffers like ($1,1,\Lambda_k$), which is the worst case.
That is why we decided, instead of testing all possible buffer shapes, to start
testing the shapes from the ideal ones ($\Lambda$) to the worst ones
($1,1,\Lambda_k$ for example), reducing the buffer shape in the $j$ dimension
first, and then in $i$.
We only estimate the amount of seeks to be produced if the maximum quantity
to be consumed is smaller than $m$.
We also added a heuristic in order not to test all shapes when it is more
probable that the best shapes are closer to $\Lambda$.
In this spirit, we added a maximum number of iteration above which the search
is stopped if no improvement in the number of seeks has been found.
We set this limit to 10 buffers.

\subsection{Limit to our implementation}
We encountered a tradeoff in the implementation of the keep algorithm which
makes its processing time longer that it could be.
Indeed, we had to implement the keep algorithm by passing data per value from
the read buffers to the cache, instead of by address.
This is due to our formulation of the re-partition problem which requires us to
be able to predict the amount of memory consumed by our algorithm to ensure that
the limit $m$ will be respected.
Python uses a custom garbage collector which manages the release of our
data structures and prevents us to force the release of some data parts.
We found that copying the data to the cache enabled us to stay below the
maximum memory consumption that we predicted at the buffer selection time.

%----------------------------------------
\section{Experiments}
%----------------------------------------
\label{sec:experiments}
\subsection{Seek model validation}

\tristan{generate 1,000 random shapes, compute number of seeks with models for baseline and keep, 
check that implementation makes the same number}

\subsection{Experimental setting}
The experiments have been executed on a private
cluster using \texttt{slurm} as workload manager. Each compute node has 256GB of
RAM, 6 SSDs of size 480 GB and 32 cores. We only used 1 node and 1 SSD at a
time.

\subsection{Comparison of the baseline and the keep algorithms}
In order to assess the keep algorithm performances, we also implemented the
baseline algorithm and ran it in the same conditions than the keep algorithm.
We did one experiment consisting in rechunking an array of shape

$R=(3500,3500,3500)$ and of type \texttt{float16} i.e. with 2 bytes per voxel.
We chose a cubic shape so that no dimension influences more the results than
the other.
Also, the sides of $R$ have been selected to be $3500$ as this number has a
reasonable amount of divisors, which makes the experiment feasible, as
$B$, $O$ and $I$ have to be divisors of $R$.

In this experiment we monitored the processing time of both algorithms, for
different amounts of main memory available.
Indeed, the keep algorithm should be faster when it has more memory available.
In order to test the algorithms in different conditions, we decided to try
several input block shapes, and for each input block shape, two output blocks
shapes have been tested. One output block shape such that $O>I$ and the other
such that $O<I$. This is interesting because when $O>I$ the ideal buffer shape
will be an input aggregate, whereas in the other case $\Lambda=I$.
The different runs have been summarized in Table~\ref{tab:exp} and indexed by
a number.

The three first input blocks have been computed as $R/4$, $R/10$ and $R/20$
(see Table~\ref{tab:exp_inblocks}).
The last input block has a shape of $(350,875,350)$ in order to be of size
approximately 100MB, as recommended by the \texttt{dask} Python package.
With $R/4$, the first input block has a size of about 670MB.
We tried those shapes as they seemed reasonable and can be found in real pipelines.
The only input block shape for which only one output block shape has not been tested
is $R/20$, as using an output block smaller than $R/20$ would be unrealistically
small (about 5.5MB).

The experiment has been run on a cluster node with 256GB, 8GB and 4GB of
available RAM for $m$. \tristan{explain how you reduced the RAM, and the impact on page cache}
The reason for using different amounts of RAM is to benchmark the keep algorithm
with different buffer shapes.
The first amount of RAM corresponds to using all the
available RAM from the compute node, whereas we chose 8 and 4GB of available RAM
because all ideal buffer shapes incured a maximum memory consumption of less than
16GB.
The buffer shapes of each run for each amount of RAM available are summarized in
Table~\ref{tab:buffer_shapes}.

\begin{table}[ht]
  \centering
  \caption{Description of the different runs of the experiment, with $R=(3500,3500,3500)$}

   \begin{tabular}[t]{| c | c | c | c | c |}
   \hline
   $I$ & $O$ & ref \\
   \hline
   \multirow{2}{*}{(875,875,875)} & (875,1750,875) & 0 \\
   & (700,875,700) & 1 \\
   \hline
   \multirow{2}{*}{(350,350,350)} & (500,500,500) & 2 \\
   & (250,250,250) & 3 \\
   \hline
   \multirow{1}{*}{(175,175,175)} & (250,250,250) & 4 \\
   \hline
   \multirow{2}{*}{(350,875,350)} & (500,875,500) & 5 \\
   & (350,500,350) & 6 \\
   \hline
   \end{tabular}

   \label{tab:exp}

\end{table}

\begin{table}[ht]
  \centering
  \caption{Description of the different input block shapes, with $R=(3500,3500,3500)$}

   \begin{tabular}[t]{| c | c | c | c | c |}
   \hline
   $I$ & size (MB) & $R/I$ \\
   \hline
   $(875,875,875)$ & 669.922 & (4,4,4) \\
   \hline
   $(350,350,350)$ & 42.875 & (10,10,10) \\
   \hline
   $(175,175,175)$ & 5.359 & (20,20,20) \\
   \hline
   $(350,875,350)$ & 107.188 & (10,4,10) \\
   \hline
   \end{tabular}

   \label{tab:exp_inblocks}

\end{table}

\begin{table}[ht]
  \centering
  \caption{Description of the different buffer shapes used for each run by the keep algorithm, depending on the amount of RAM available. The last column gives the maximum RAM consumption estimated by the keep algorithm before running (at buffer selection time).}

   \begin{tabular}[t]{| c | c | c | c |}
   \hline
   $m$ & ref & buffer shape & maximum estimated (MB) \\
   \hline
   \multirow{2}{*}{256GB} & 0 & (875, 1750, 875) & 2,679.6875 \\
   & 1 & (875, 875, 875) &  14,631.09375 \\
   & 2 & (700, 700, 700) &  11,596.0 \\
   & 3 & (350, 350, 350) &  5,255.75 \\
   & 4 & (350, 350, 350) &  5,255.75 \\
   & 5 & (700, 875, 700) &  10,920.0 \\
   & 6 & (350, 875, 350) &  1,133.125 \\
   \hline
   \multirow{2}{*}{8GB} & 0 & (875, 1750, 875) & 2,679.6875 \\
   & 1 & (700, 875, 875) &  1,715.0 \\
   & 2 & (500, 700, 700) &  2,040.0 \\
   & 3 & (350, 350, 350) &  5,255.75 \\
   & 4 & (350, 350, 350) &  5,255.75 \\
   & 5 & (500, 875, 700) &  962.5 \\
   & 6 & (350, 875, 350) &  1,133.125 \\
   \hline
   \multirow{2}{*}{4GB} & 0 & (875, 1750, 875) & 2,679.6875 \\
   & 1 & (700, 875, 875) &  1,715.0 \\
   & 2 & (500, 700, 700) &  2,040.0 \\
   & 3 & (250, 350, 350) &  430.0 \\
   & 4 & (250, 350, 350) &  430.0 \\
   & 5 & (500, 875, 700) &  962.5 \\
   & 6 & (350, 875, 350) &  1,133.125 \\
   \hline
   \end{tabular}

   \label{tab:buffer_shapes}

\end{table}

\subsection{Results}

The results in terms of processing times are shown on
Figure~\ref{fig:results}, whereas the results in terms of seeks are
presented on Figure~\ref{fig:seeks_results}.

Looking at Figure~\ref{fig:results}, we can see that
the baseline algorithm performs surprisingly well compared to the keep algorithm
when the main memory available is 256GB (all the node's available RAM).
We can see that when the amount of RAM available decreases (8 and 4GB), the
performances of the baseline algorithm decreases drastically.
In particular, the keep algorithm is approximately 2 times faster for runs
2, 3 and 4 on Figure~\ref{fig:results4}.
From these observations we suppose that the baseline algorithm performs well
with 256GB because it leverages the page cache.
It is counter-intuitive to see that the performances of the baseline algorithm
differs for the different amount of RAM available, because apart from $m$
nothing changes for the baseline algorithm; the read buffer shape stays $B=I$.

Another factor for the baseline algorithm to perform well compared to the
keep algorithm with 256GB is the time overhead of the keep algorithm which is
very important as one can see on Figure~\ref{fig:results}.
This is due to our implementation and the tradeoff presented in section
``Implementation".
Concretely, the time overhead is mainly due to making copies of the data from
the read buffers to the cache.
In terms of read/write processing time however, we can clearly see an
important speedup by the keep algorithm compared to the baseline for
runs 3 and 4 (Figure~\ref{fig:results}).
One can also notice a non-negligible speedup for runs 1 to 5 for the experiment
with 8 (Figure~\ref{fig:results8}) and 4GB (Figure~\ref{fig:results4}).
There are big differences in the benefits of using the keep algorithm instead of
the baseline algorithm, depending on the different runs.
This is due to the difference in complexity between the runs.
The runs that are more complex (with more shape mismatches) are more optimized
by the keep algorithm, hence producing a bigger speedup from the keep compared to
the baseline.

Considering Figure~\ref{fig:seeks_results}, one can see that the number of
seeks is drastically reduced by the keep algorithm, which is consistent with
the results in terms of processing time.
We remark that one needs to reduce significantly the amount of seeks produced
by a re-partition algorithm to clearly see an impact on the processing time.
Considering run 4 which shows the most important differences in terms of
processing time, the amount of seeks have been reduced from about 100 millions
seeks to thousands of seeks.
We also remark that although the number of seeks have been reduced from millions
to thousands of seeks for runs 1 to 5, the reduction in processing time does not
follow linearly the reduction in the number of seeks.
This is probably due to the fact that some seeks are more costly than others,
which has not been taken into account in our problem formulation.

\begin{figure*}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[scale=0.5]{./figures/new/results_256.png}
         \caption{Processing times for $m=256$GB}
         \label{fig:results256}
     \end{subfigure}
     \vfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[scale=0.5]{./figures/new/results_8.png}
         \caption{Processing times for $m=8$GB}
         \label{fig:results8}
     \end{subfigure}
     \vfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[scale=0.5]{./figures/new/results_4.png}
         \caption{Processing times for $m=4$GB}
         \label{fig:results4}
     \end{subfigure}

     \caption{Results in terms of processing time for the keep and baseline algorithms. From top to bottom, the results are presented for 256, 8 and 4GB of available main memory.}
     \label{fig:results}

\end{figure*}

\begin{figure*}
     \centering
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[scale=0.5]{./figures/new/results_seeks_256.png}
         \caption{Seek quantities for $m=256$GB}
         \label{fig:seeks256}
     \end{subfigure}
     \vfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[scale=0.5]{./figures/new/results_seeks_8.png}
         \caption{Seek quantities for $m=8$GB}
         \label{fig:seeks8}
     \end{subfigure}
     \vfill
     \begin{subfigure}[b]{\textwidth}
         \centering
         \includegraphics[scale=0.5]{./figures/new/results_seeks_4.png}
         \caption{Seek quantities for $m=4$GB}
         \label{fig:seeks4}
     \end{subfigure}

     \caption{Results in terms of seeks for the keep and baseline algorithms. From top to bottom, the results are presented for 256, 8 and 4GB of available main memory.}
     \label{fig:seeks_results}
\end{figure*}

%----------------------------------------
\section{Discussion}
%----------------------------------------
\tristan{From discussion with Valerie, mention practical considerations related to page cache and readahead}

\subsection{On the keep algorithm}
The keep algorithm can reduce the number of seeks produced by a re-partition
problem from millions to thousands of seeks, compared to the baseline algorithm.
Even if the write time has been drastically reduced on the results shown on
Figure~\ref{fig:results}, there is still margin for improvement in optimizing
the read time.
Finally, it could be interesting to try identifying the type of seeks that are
more costly than the others and focus future implementations of the re-partition
algorithm to reduce such costly seeks.

Although the keep algorithm can be 2 times faster than the baseline algorithm
in some cases, our implementation suffers from a tradeoff between optimizing
the processing time and predicting the maximum amount of memory consumed.
In some non-complex cases, the baseline algorithm can be as efficient as the
keep algorithm.
Moreover, the baseline algorithm seems to take advantage of the surplus of
main memory available in the node, although in theory it is supposed to use
only the size of one input block in bytes at a time.
This does not seem to be the case of the keep algorithm for which the maximum
amount of main memory consumed can be estimated before run.

\subsection{The buffer ordering problem}
The buffer order is important when using the keep strategy, as it defines when
a piece of data will be loaded and when a write buffer will be complete, hence
ready to be written down and freed from the cache.
Representing the read buffers by a complete bidirectional graph in which each
vertex is a buffer, we can model the problem as kind of a complex shortest path
problem.
Indeed, for a given buffer shape $B$, we want to find the read buffers order
that will keep the amount of memory used by the re-partition algorithm low.
Solving this problem would incur more infering at runtime and a potentially
complex algorithm to run.
We decided to keep things simple using a naive buffer order, as the goal of
this study was primarily to assess if the keep algorithm works.

\subsection{Impact of the buffer order on performance}
Using the keep strategy, one may order the buffer loadings to reduce the maximum
quantity of extra data stored in memory, hence, reducing the amount of seeks.
For example, if the shape mismatches occur only in the $k$ axis, loading the
buffers in this direction will enable recycling the extra data in cache,
resulting in a smallest memory consumption over time.
The memory saved thanks to a smart
ordering could enable the storage of more extra data in memory using the
keep strategy, further reducing the amount of seeks produced.

As explained in the discussion, the buffer ordering problem is complex and does
not seem easily solvable.
This study uses a naive order which is, again, the inverse storage order.
The reason for that order is that as it is more important to keep data in the
$k$ dimension to save seeks and we assume that $B_k=\Lambda_k$, it seems
reasonable to load the buffers in the $k$ dimension first.
Note that using such
an order recycles extra data in the $k$ dimension first; It is therefore
more efficient when the biggest shape mismatch between the input and output
blocks is in $k$.

Thanksfully, the impact of the buffer ordering on performance can be
mitigated. Indeed, the impact of the buffer ordering depends on the size of the
mismatches. One can reduce the amount of extra data by using smallest blocks: Even
if the overlap between the input and output files is big with respect to their
size, the area/volume of the overlap will be kept small.

\subsection{ROI extraction problem}
The Region Of Interest (ROI) extraction problem is a related problem that still
needs to be adressed.
A solution using chunking as been introduced in~\cite{optimal_chuking}.
The authors define an array partitioned into chunks of equal shapes and then
define a query as an arbitrary subarray of the input, chunked, array.
They define the optimal chunking problem as finding the optimal chunk such
that the expected number of chunks retrieved to answer the query is minimal.

In our opinion, the solution in~\cite{optimal_chuking} is limited due to the
need of historical or theoretical workload and the necessity to repartition the
input array into an ``optimal" chunk shape.
We would prefer letting the application choose the appropriate chunk shape
regarding its needs and not needing to estimate the processing workload.
We define the ROI extraction problem as follows: Finding an algorithm that takes
as input an arbitrary chunk shape and extract the ROI data from the chunks with
the less number of seeks as possible.

\subsection{Solving three problems at once}
As stated in the introduction, the split and merge tasks are special cases of
the repartition task. This observation leads us to think that maybe one could find
one optimal algorithm for the split, merge and repartition tasks.

If we were to use the keep algorithm with $I=R$, we would read the input data
in slices, exactly like the multiple strategy. The only difference between the
two strategies, however, is that if some remainders appear at the bottom of the
buffer, the keep algorithm would keep it to try to read and write files in one
seek. Not only the keep algorithm tries to limit seeking into the files but it
also tries to limit switching between the files. It would be interesting to
compare the two algorithms for the split/merge tasks to see if the keep
implementation brings similar results or any kind of improvement.

\subsection{The dask Python package}
\texttt{dask} is a popular Python package, part of the SciPy ecosystem, enabling
parallel and out-of-core computations~\cite{matthew_rocklin-proc-scipy-2015}.
It has an important scientific community which is likely to have the problem we
try to solve in this paper, i.e. re-partitioning multidimensional array files.
That is why we would find it interesting to implement our work as an optimization
package for \texttt{dask}.
In particular, we would focus on the \texttt{dask.array} collection, a data
structure designed for multi-dimensional array processing using blocked
algorithms.

\texttt{dask} represents computations as task graphs that are dynamically executed by one
of several schedulers including the single-threaded, the multi-threaded, the
multi-process, and the distributed schedulers. Custom schedulers can also be
implemented. \texttt{dask} graphs can be used out-of-the-box or through
built-in APIs. A \texttt{dask} graph is implemented in plain Python as a
dictionary with any hashable as keys and any object as values. More precisely,
a ``Value" is any object different than a task and a ``Task" is a tuple with a
callable as first element. Examples of APIs/collections include
\texttt{dask.array}, a parallel and out-of-core
Numpy clone, and \texttt{dask.dataframe}, a Pandas clone.
Our first prototype of implementation of the keep algorithm is showing promising
results in optimizing the computation graphs produced by \texttt{dask}.

\subsection{Towards distributed systems}
As most of the big data processing is now done on clusters, it could be interesting
to find distributed versions of the split/merge/re-partition algorithms.
Lots of scientists use HPC (High Performance Computing) clusters regularly which
brings considerations about how to use such distributed algorithms with Lustre
for example, a commonly used filesystem for HPC.

\texttt{dask} also provides a distributed scheduler that seems to be quite
efficient.
It is now recommended for use, even on local computers (using one node).

%----------------------------------------
\section{Conclusion}
%----------------------------------------

Multidimensional array chunking is a routine for scientists nowadays.
That is why efficiently processing such arrays is of major importance in the big data era.

Splitting and merging arrays has been successfully done, we therefore attempted
to solve the next step: the re-partitioning problem.
This problem consists in efficiently re-writing a chunked array to change the blocks shape.
We think that solving this problem could enable us to solve the ROI (region of interest)
extraction problem in the future, which is also a very common problem for scientists.
We formally defined the re-partitioning problem together with a \emph{baseline algorithm} to solve it.
We also presented the \emph{keep algorithm} to reduce the number of seeks produced during
the re-partitioning and hopefully reduce the processing time of such task.
The keep algorithm reduces the number of seeks by
(1) constraining the read buffers shape to minimize the read time, and
(2) leveraging a ``cache" to minimize the write time.

Although the re-partitioning problem is more complex than splitting/merging chunks,
we proved that it can be optimized and that it is possible to reduce the
processing time significantly.
Surprisingly however, the baseline algorithm has been found to perform pretty
well when there is a lot of memory available as it leverages the page cache to
speedup computations without reducing the number of seeks.
For now, the keep algorithm may be more interesting than the baseline algorithm
only when the memory constraint is important ($m$ small compared to the array size).

In the future, the algorithm performances may be improved by finding a variant
to the keep algorithm that also reduce the read time significantly,
identifying and focusing on reducing the most expensive seeks,
and finally, finding parrallel and/or distributive versions of the keep algorithm.

%----------------------------------------
\section{Acknowledgments}
%----------------------------------------

The computing platform was obtained with funding from the Canada Foundation for Innovation.

\tristan{Timothée, make sure that all references have a title, date, and venue (journal or conference name). 
Check capitalization of words like HDF5, etc}

\bibliography{Bibliography}
\bibliographystyle{ieeetr}

\end{document}
