\relax 
\citation{Amunts1472}
\citation{seqalgorithms}
\citation{seqalgorithms}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-A}}Context}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-B}}Problem definition}{1}}
\citation{seqalgorithms}
\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces Basic resplit algorithm}}{2}}
\newlabel{algo:generalresplit}{{1}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-C}}Consistency with previous works}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Illustration of the reconstructed image divided into input files at the initialization of the resplit algorithm. }}{2}}
\newlabel{fig:reconstructed_img_divided}{{1}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-D}}Naive algorithm}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-E}}A particular case}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Illustration of the column-order storage of voxels in a file. }}{3}}
\newlabel{fig:column_order}{{2}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-F}}The ``keep" strategy}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Illustration of the concept of extra data with a 2D case. In this example the black bordered rectangles represent the input files and the gray bordered rectangles represent the output files. After having read the red buffer we can see that the output file covered by the light red area can be written directly. After having written the data from the light red area however, we are left with the dark red, dotted area which represents some extra data we would like to keep in memory until we read the rest of the incomplete ouptut files in order to read the incomplete output files with one seek. }}{3}}
\newlabel{fig:overlap}{{3}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-G}}Input aggregates}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Illustration of the keep strategy with a 2D case. In this example the black bordered rectangles represent the input files and the gray bordered rectangles represent the output files. As shown on the left figure, the keep strategy consists in reading more than one output file (light red area) into the first buffer. Then the first output file is written and the dark red area is kept in memory. On the left figure the second buffer has been loaded. It allows to free part of the overlap in the $k$ direction (the green area) as the second file data is complete in main memory. The third output file has been read completely and can therefore be written. This lets the overlap in the $j$ direction (dark red area) in main memory for the next buffer. }}{4}}
\newlabel{fig:keepstrategy}{{4}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces First buffer in the column-order storage. }}{4}}
\newlabel{fig:firstbuffer}{{5}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Illustration of an input aggregate in two dimensions. On the left schema, consider the surface containing all rectangles as being the reconstructed image, with the small rectangles (with black borders) being the input files and the big rectangles (with gray borders) being the output files. On the right side an input aggregate is illustrated by the red area: it is the smallest number of input files such that the surface of at least one output file is completely covered. In this example, four input files are required to cover the first output file. }}{4}}
\newlabel{fig:input_aggregates}{{6}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-H}}Stretching the buffer in the storage order}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Left figure: without keep strategy. Right: with keep strategy. Keeping extra data in memory reduces the number of seeks caused by writing but increases the number of buffers needed to write an output file. The crosses represent the number of seeks that happen in both cases. }}{5}}
\newlabel{fig:case_1_2}{{7}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Illustration of an overlap in the $j$ dimension. The black crosses represents one seek each. In the 2D case on the left we can see that writing down the data into the next output file on the right would take only one seek. In the 3D case however (right side), writing the data down into the next output file would take $B_i$ seeks. }}{5}}
\newlabel{fig:case_2_1}{{8}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Illustration of the different overlaping areas in 2D. The blue area is called the $f_1$ area, the red area is called the $f_3$ area and we call $f_2$ area the green one. }}{5}}
\newlabel{fig:areasabc}{{9}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-I}}Stretching beyond the input aggregate shape}{5}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {2}{\ignorespaces Pseudocode of the ``keep" algorithm in 3D}}{5}}
\newlabel{algo:keep_algorithm_3D}{{2}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces  Left side: Extending the buffer to the next input length. Right side: Extending the buffer to the next output length. The crosses indicates the number of seeks. As we can see, extending the buffer to the next output shape incurs a lot of seeks in the next input file when loading the buffer. As the input file is incomplete, there is no extra data, therefore the keep strategy cannot be used. }}{6}}
\newlabel{fig:extendingbuffers}{{10}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-J}}Special case of non optimality}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-K}}Impact of the buffer order on performance}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-L}}Nomenclature}{6}}
\bibdata{Bibliography}
\bibcite{Amunts1472}{1}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces  Comparison of a bad buffer ordering (left side) against a good buffer ordering (right side), given an overlap in the $k$ dimension. The red area represents the amount of extra data kept in memory after loading the third buffer. The right side order allowed to release the extra data from the first buffer after reading the second buffer. }}{7}}
\newlabel{fig:goodorderingbadordering}{{11}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-M}}A ``naive" buffer ordering}{7}}
\newlabel{eq:1}{{1}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-N}}The buffer extension algorithm}{7}}
\bibcite{seqalgorithms}{2}
\bibstyle{ieeetr}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Figure (a) represents an input aggregate of shape $\Lambda $. The white cube represents the data that can be written directly into output files and the other blue blocks represent incomplete files. Figure (b) shows how the different volumes are indexed following the buffer order. Here the buffer order is the storage order. Another way of naming volumes is by using the decimal value or their positions, for example (0,0,1) is block 1, (1,1,0) is block 6. }}{8}}
\newlabel{fig:nomenclature_overlaps}{{12}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces On both figures the solid black borders blocks are buffers and the dotted red blocks are output files. We consider a buffer of interest with a thick black border. The red areas represent the extra data loaded by the buffer of interest and the blue areas represent the extra data kept in memory from the previous buffer loadings. On figure (a) an overlap in the first buffer order dimension is shown. One can see that each buffer recycles the previous extra data such that one never store more that the size of a buffer plus the size of $F_1$ in memory during the resplit process. Figure (b) shows that an overlap in the second dimension of the buffer order has to be kept in memory $b_k$ times with $b_k$ the number of buffers in the $k^{th}$ dimension. This can be extended to 3D by adding the overlaps in the third dimension of buffer order $N_s$ times with $N_s$ the number of buffers in a buffer slice. }}{8}}
\newlabel{fig:naive_buffer_order}{{13}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-O}}Usage and support for MINC/Nifti file formats}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-P}}Comparison with previous work}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-Q}}Solution of the ordering problem}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-R}}Extending the algorithm for ROI extraction}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-S}}Distributed keep algorithm}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-T}}Future works}{8}}
\@writefile{toc}{\contentsline {section}{References}{8}}
\@writefile{toc}{\contentsline {section}{Appendix\nobreakspace  A: Formulas for buffer extension}{8}}
\newlabel{FormulasKeep}{{A}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-A}}Overlap volume memory sizes}{8}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {3}{\ignorespaces Buffer extension algorithm (part 1)}}{9}}
\newlabel{algo:buffer_extension_1}{{3}{9}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {4}{\ignorespaces Buffer extension algorithm (part 2)}}{9}}
\newlabel{algo:buffer_extension_2}{{4}{9}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {5}{\ignorespaces Buffer extension algorithm (part 3)}}{9}}
\newlabel{algo:buffer_extension_3}{{5}{9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-B}}Maximum amount of overlap to keep in memory}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-C}}Keeping f1}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-D}}Keeping f3}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-E}}Keeping f2}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-F}}Increasing f1, f2, f3 to F1, F2, F3}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-G}}Keeping F5, F6, F7}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {A-H}}Keeping F4}{10}}
\@writefile{lof}{\contentsline {figure}{\numberline {14}{\ignorespaces Figure (a). Figure (b). }}{11}}
\newlabel{fig:g_s}{{14}{11}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {6}{\ignorespaces Pseudocode for addInputFileLength}}{11}}
\newlabel{algo:addInputFileLength}{{6}{11}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {7}{\ignorespaces Pseudocode for computeSigma3D}}{11}}
\newlabel{algo:computeSigma3D}{{7}{11}}
