\relax 
\citation{seqalgorithms}
\citation{seqalgorithms}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-A}}Context}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-B}}Problem definition}{1}}
\citation{seqalgorithms}
\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces Basic resplit algorithm}}{2}}
\newlabel{algo:generalresplit}{{1}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-C}}Consistency with previous works}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Illustration of the reconstructed image divided into input files at the initialization of the resplit algorithm. }}{2}}
\newlabel{fig:reconstructed_img_divided}{{1}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-D}}Naive algorithm}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-E}}A particular case}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-F}}The ``keep" strategy}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Illustration of the column-order storage of voxels in a file. }}{3}}
\newlabel{fig:column_order}{{2}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Illustration of the concept of extra data with a 2D case. In this example the black bordered rectangles represent the input files and the gray bordered rectangles represent the output files. After having read the red buffer we can see that the output file covered by the light red area can be written directly. After having written the data from the light red area however, we are left with the dark red, dotted area which represents some extra data we would like to keep in memory until we read the rest of the incomplete ouptut files in order to read the incomplete output files with one seek. }}{3}}
\newlabel{fig:overlap}{{3}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-G}}Input aggregates}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-H}}Stretching the buffer in the storage order}{3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Illustration of the keep strategy with a 2D case. In this example the black bordered rectangles represent the input files and the gray bordered rectangles represent the output files. As shown on the left figure, the keep strategy consists in reading more than one output file (light red area) into the first buffer. Then the first output file is written and the dark red area is kept in memory. On the left figure the second buffer has been loaded. It allows to free part of the overlap in the $k$ direction (the green area) as the second file data is complete in main memory. The third output file has been read completely and can therefore be written. This lets the overlap in the $j$ direction (dark red area) in main memory for the next buffer. }}{4}}
\newlabel{fig:keepstrategy}{{4}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces First buffer in the column-order storage. }}{4}}
\newlabel{fig:firstbuffer}{{5}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Illustration of an input aggregate in two dimensions. On the left schema, consider the surface containing all rectangles as being the reconstructed image, with the small rectangles (with black borders) being the input files and the big rectangles (with gray borders) being the output files. On the right side an input aggregate is illustrated by the red area: it is the smallest number of input files such that the surface of at least one output file is completely covered. In this example, four input files are required to cover the first output file. }}{4}}
\newlabel{fig:input_aggregates}{{6}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-I}}Stretching beyond the input aggregate shape}{4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-J}}Pseudo-code of the algorithm}{4}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Left figure: without keep strategy. Right: with keep strategy. Keeping extra data in memory reduces the number of seeks caused by writing but increases the number of buffers needed to write an output file. The crosses represent the number of seeks that happen in both cases. }}{5}}
\newlabel{fig:case_1_2}{{7}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces Illustration of an overlap in the $j$ dimension. The black crosses represents one seek each. In the 2D case on the left we can see that writing down the data into the next output file on the right would take only one seek. In the 3D case however (right side), writing the data down into the next output file would take $B_i$ seeks. }}{5}}
\newlabel{fig:case_2_1}{{8}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces Illustration of the different overlaping areas in 2D. The blue area is called the $a$ area, the red area is called the $b$ area and we call $c$ area the green one. }}{5}}
\newlabel{fig:areasabc}{{9}{5}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {2}{\ignorespaces getBufferShape in ND}}{5}}
\newlabel{algo:getbuffershape}{{2}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces  Left side: Extending the buffer to the next input length. Right side: Extending the buffer to the next output length. The crosses indicates the number of seeks. As we can see, extending the buffer to the next output shape incurs a lot of seeks in the next input file when loading the buffer. As the input file is incomplete, there is no extra data, therefore the keep strategy cannot be used. }}{6}}
\newlabel{fig:extendingbuffers}{{10}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-K}}Special case of non optimality}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-L}}Impact of the buffer order on performance}{6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-M}}A ``naive" buffer ordering}{6}}
\bibdata{Bibliography}
\bibcite{seqalgorithms}{1}
\bibstyle{ieeetr}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces  Comparison of a bad buffer ordering (left side) against a good buffer ordering (right side), given an overlap in the $k$ dimension. The red area represents the amount of extra data kept in memory after loading the third buffer. The right side order allowed to release the extra data from the first buffer after reading the second buffer. }}{7}}
\newlabel{fig:goodorderingbadordering}{{11}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-N}}Overlap sizes in 3D}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-O}}Putting all together}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-P}}Usage and support for MINC/Nifti file formats}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-Q}}Comparison with previous work}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-R}}Solution of the ordering problem}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-S}}Extending the algorithm for ROI extraction}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-T}}Distributed keep algorithm}{7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {-U}}Improvements}{7}}
\@writefile{toc}{\contentsline {section}{References}{7}}
